
'use strict';

var Transfer, self;

/**
 * @class Transfer
 * @desc Transfer files in async
 */
module.exports = Transfer = function (config, _super) {

    self = this;

	self._super = _super;

    /*!
     * Keep track of file upload info in q object, structure:
     * {String} Job id: {
     *      data: {Object} File object
     *      chunkNum: {Int} Current chunk to be sent
     *      chunkCount: {Int} Number of chunks in file
     *  }
     */
    self.q = {};

    // size of each chunk
    self.chunkSize = 1000 || config.chunkSize;

    // socket connection
    self.socket = require('./socket')(config);

    /*!
     * Listening to websocket messages
     */

    // TODO: Don't assume a websocket connection exists,
    //       then we can  remove the below try-catch.
    try {
        self.socket.onmessage = function (message) {

            var resp = message.data;
            try {
                // Upon parsing the message, check if the job id is
                // registered in our self.q object. If it is, process it
                resp = JSON.parse(resp);

                return self.q[resp.id] ? (function () {

                    // update the q object
                    self.q[resp.id].chunkNum = resp.chunkNum;
                    self.q[resp.id].done = resp.done;

                    self.process(resp.id);

                })() : console.warn('Upper.js: ' + message.error);

            } catch (err) {
                // Return debug message to browser console
                console.warn('Upper.js: Error parsing websocket');
            }
        };
    } catch (err) {}
};

/**
 * @method add
 * @desc Add a file to the uploader's queue
 */
Transfer.prototype.add = function (file) {

    var id = Math.random().toString(36).substr(2, 5);

    self.q[id] = {
        data: file,
        chunkNum: 0,
        chunkCount: Math.ceil(file.size / self.chunkSize),
        meta: self._super.meta
    };

    self.process(id);

    return id;
};

/**
 * @method process
 * @desc Send a chunk
 */
Transfer.prototype.process = function (id) {

    var file = self.q[id],
        data = file.data,
        uploadReader = new window.FileReader();

    uploadReader.readAsBinaryString(data.slice(file.chunkNum * self.chunkSize,
                                              (file.chunkNum * self.chunkSize) + self.chunkSize));

    // data from file blob callback
    uploadReader.onload = function (e) {

        // if file is done uploading chunks
        if(file.done) {

            // send upload completion status to user
            self._super.emit('completed', file.done);

            // remove file from .q
            delete self.q[id];

        } else { // otherwise keep on iterating chunks

            // send file chunk to server
            self.socket.emit({
                id: id,
                name: data.name,
                size: data.size,
                chunkNum: file.chunkNum,
                chunkCount: file.chunkCount,
                data: e.target.result,
				meta: file.meta
            });

            // send upload progress to user
            self._super.emit('progress', {
                id: id,
                file: data.name,
                size: data.size,
                percent: (file.chunkNum / file.chunkCount) * 100
            });
        }

        file.chunkNum++;
    };
    return file.id;
};
